<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test: Correcci√≥n Final de Notificaciones de Evaluaci√≥n</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .test-section { border: 2px solid #ccc; margin: 10px 0; padding: 20px; }
        .pass { border-color: green; background-color: #f0fff0; }
        .fail { border-color: red; background-color: #fff0f0; }
        .test-header { font-weight: bold; font-size: 1.2em; margin-bottom: 10px; }
        .step { margin: 10px 0; padding: 10px; background-color: #f5f5f5; }
        .result { font-weight: bold; margin-top: 10px; }
        pre { background-color: #eee; padding: 10px; overflow-x: auto; }
    </style>
</head>
<body>
    <h1>üîß Test: Correcci√≥n Final de Notificaciones de Evaluaci√≥n</h1>
    <p><strong>Objetivo:</strong> Verificar que las notificaciones de evaluaci√≥n incluyan el taskType y se filtren correctamente</p>

    <div id="test-results"></div>

    <script>
        // Simulaci√≥n de la interfaz TaskNotification
        class TaskNotificationManager {
            static STORAGE_KEY = 'smart-student-task-notifications';

            static getNotifications() {
                const stored = localStorage.getItem(this.STORAGE_KEY);
                return stored ? JSON.parse(stored) : [];
            }

            static saveNotifications(notifications) {
                localStorage.setItem(this.STORAGE_KEY, JSON.stringify(notifications));
            }

            static getStudentsInCourse(course) {
                // Simulaci√≥n de estudiantes
                return [
                    { username: 'luis_estudiante', displayName: 'Luis Estudiante' },
                    { username: 'maria_estudiante', displayName: 'Mar√≠a Estudiante' }
                ];
            }

            // ‚úÖ FUNCI√ìN ACTUALIZADA: Ahora incluye taskType
            static createNewTaskNotifications(taskId, taskTitle, course, subject, teacherUsername, teacherDisplayName, taskType = 'assignment') {
                console.log('=== DEBUG createNewTaskNotifications ===');
                console.log('TaskId:', taskId);
                console.log('Course:', course);
                console.log('TaskType:', taskType); // üî• NUEVO LOG
                
                const studentsInCourse = this.getStudentsInCourse(course);
                console.log('Students found in course:', studentsInCourse);
                
                if (studentsInCourse.length === 0) {
                    console.log('No students found in course, skipping notification creation');
                    return;
                }

                const notifications = this.getNotifications();
                console.log('Current notifications count:', notifications.length);
                
                const newNotification = {
                    id: `new_task_${taskId}_${Date.now()}`,
                    type: 'new_task',
                    taskId,
                    taskTitle,
                    targetUserRole: 'student',
                    targetUsernames: studentsInCourse.map(student => student.username),
                    fromUsername: teacherUsername,
                    fromDisplayName: teacherDisplayName,
                    course,
                    subject,
                    timestamp: new Date().toISOString(),
                    read: false,
                    readBy: [],
                    taskType // üî• AGREGADO: Incluir el tipo de tarea
                };

                notifications.push(newNotification);
                console.log('New notification created:', newNotification);
                console.log('Total notifications after creation:', notifications.length);
                
                this.saveNotifications(notifications);
                console.log('Notifications saved to localStorage');
            }

            static isEvaluationCompletedByStudent(taskId, studentUsername) {
                try {
                    const userTasksKey = `userTasks_${studentUsername}`;
                    const userTasks = JSON.parse(localStorage.getItem(userTasksKey) || '[]');
                    
                    const task = userTasks.find(t => t.id === taskId);
                    return task && task.status === 'completed';
                } catch (error) {
                    console.error('Error checking evaluation completion:', error);
                    return false;
                }
            }

            static removeEvaluationNotificationOnCompletion(taskId, studentUsername) {
                const notifications = this.getNotifications();
                console.log(`[removeEvaluationNotificationOnCompletion] Filtering notifications for task ${taskId}, student ${studentUsername}`);
                
                let removedCount = 0;
                const filteredNotifications = notifications.filter(notification => {
                    if (notification.type === 'new_task' && 
                        notification.taskId === taskId && 
                        notification.targetUsernames.includes(studentUsername)) {
                        
                        if (notification.targetUsernames.length > 1) {
                            // M√∫ltiples destinatarios: solo remover este estudiante
                            notification.targetUsernames = notification.targetUsernames.filter(
                                username => username !== studentUsername
                            );
                            console.log(`[removeEvaluationNotificationOnCompletion] Removed student ${studentUsername} from notification`);
                            return true; // Mantener notificaci√≥n modificada
                        } else {
                            // √önico destinatario: eliminar completamente
                            console.log(`[removeEvaluationNotificationOnCompletion] Removing notification completely for ${studentUsername}`);
                            removedCount++;
                            return false; // Eliminar notificaci√≥n
                        }
                    }
                    return true; // Mantener todas las dem√°s notificaciones
                });

                if (removedCount > 0 || filteredNotifications.some(n => n.type === 'new_task' && n.taskId === taskId)) {
                    this.saveNotifications(filteredNotifications);
                    console.log('Evaluation notifications updated after student completion');
                }
            }

            static getUnreadNotificationsForUser(username, userRole) {
                const notifications = this.getNotifications();
                return notifications.filter(notification => {
                    // Filtros b√°sicos
                    const basicFilters = notification.targetUserRole === userRole &&
                        notification.targetUsernames.includes(username) &&
                        !notification.readBy.includes(username) &&
                        notification.fromUsername !== username;

                    if (!basicFilters) return false;

                    // Para estudiantes: filtrar evaluaciones completadas
                    if (userRole === 'student' && notification.type === 'new_task') {
                        // Verificar si la tarea es una evaluaci√≥n y si ya fue completada
                        if (notification.taskType === 'evaluation') {
                            const isCompleted = this.isEvaluationCompletedByStudent(notification.taskId, username);
                            if (isCompleted) {
                                console.log(`[getUnreadNotificationsForUser] Filtering out completed evaluation: ${notification.taskTitle} for student: ${username}`);
                                return false;
                            }
                        }
                    }

                    return true;
                });
            }
        }

        // Funci√≥n de testing
        function runTests() {
            const resultsDiv = document.getElementById('test-results');
            let allTestsPassed = true;

            function addTest(title, testFunction) {
                const testDiv = document.createElement('div');
                testDiv.className = 'test-section';
                
                const headerDiv = document.createElement('div');
                headerDiv.className = 'test-header';
                headerDiv.textContent = title;
                testDiv.appendChild(headerDiv);

                try {
                    const result = testFunction();
                    if (result.success) {
                        testDiv.classList.add('pass');
                        headerDiv.textContent += ' ‚úÖ PASSED';
                    } else {
                        testDiv.classList.add('fail');
                        headerDiv.textContent += ' ‚ùå FAILED';
                        allTestsPassed = false;
                    }
                    
                    const resultDiv = document.createElement('div');
                    resultDiv.className = 'result';
                    resultDiv.innerHTML = result.message;
                    testDiv.appendChild(resultDiv);
                    
                } catch (error) {
                    testDiv.classList.add('fail');
                    headerDiv.textContent += ' ‚ùå ERROR';
                    allTestsPassed = false;
                    
                    const errorDiv = document.createElement('div');
                    errorDiv.className = 'result';
                    errorDiv.innerHTML = `<strong>Error:</strong> ${error.message}`;
                    testDiv.appendChild(errorDiv);
                }

                resultsDiv.appendChild(testDiv);
            }

            // Limpiar localStorage antes de las pruebas
            localStorage.clear();

            // Test 1: Verificar que las notificaciones incluyan taskType
            addTest('Test 1: Notificaciones incluyen taskType', () => {
                TaskNotificationManager.createNewTaskNotifications(
                    'eval_001',
                    'Evaluaci√≥n de Matem√°ticas',
                    'matematicas_6to',
                    'Matem√°ticas',
                    'prof_gonzalez',
                    'Profesor Gonz√°lez',
                    'evaluation' // üî• NUEVO PAR√ÅMETRO
                );

                const notifications = TaskNotificationManager.getNotifications();
                const evalNotification = notifications.find(n => n.taskId === 'eval_001');
                
                if (!evalNotification) {
                    return { success: false, message: 'No se encontr√≥ la notificaci√≥n creada' };
                }

                if (evalNotification.taskType !== 'evaluation') {
                    return { success: false, message: `TaskType incorrecto: esperado 'evaluation', obtenido '${evalNotification.taskType}'` };
                }

                return { 
                    success: true, 
                    message: `‚úÖ Notificaci√≥n creada correctamente con taskType: '${evalNotification.taskType}'<br>
                              üìã ID: ${evalNotification.id}<br>
                              üë• Destinatarios: ${evalNotification.targetUsernames.join(', ')}` 
                };
            });

            // Test 2: Verificar filtrado de evaluaciones completadas
            addTest('Test 2: Filtrado de evaluaciones completadas', () => {
                // Simular que Luis complet√≥ la evaluaci√≥n
                const luisUserTasks = [
                    { id: 'eval_001', status: 'completed', completedAt: new Date().toISOString() }
                ];
                localStorage.setItem('userTasks_luis_estudiante', JSON.stringify(luisUserTasks));

                // Obtener notificaciones para Luis
                const luisNotifications = TaskNotificationManager.getUnreadNotificationsForUser('luis_estudiante', 'student');
                const luisEvalNotifications = luisNotifications.filter(n => n.taskId === 'eval_001');

                // Obtener notificaciones para Mar√≠a (no complet√≥)
                const mariaNotifications = TaskNotificationManager.getUnreadNotificationsForUser('maria_estudiante', 'student');
                const mariaEvalNotifications = mariaNotifications.filter(n => n.taskId === 'eval_001');

                if (luisEvalNotifications.length > 0) {
                    return { 
                        success: false, 
                        message: `‚ùå Luis a√∫n ve ${luisEvalNotifications.length} notificaci√≥n(es) de evaluaci√≥n completada` 
                    };
                }

                if (mariaEvalNotifications.length === 0) {
                    return { 
                        success: false, 
                        message: `‚ùå Mar√≠a no ve notificaciones de evaluaci√≥n pendiente` 
                    };
                }

                return { 
                    success: true, 
                    message: `‚úÖ Filtrado correcto:<br>
                              üë§ Luis (completada): ${luisEvalNotifications.length} notificaciones<br>
                              üë§ Mar√≠a (pendiente): ${mariaEvalNotifications.length} notificaciones` 
                };
            });

            // Test 3: Verificar eliminaci√≥n de notificaciones al completar
            addTest('Test 3: Eliminaci√≥n al completar evaluaci√≥n', () => {
                // Contar notificaciones antes
                const notificationsBefore = TaskNotificationManager.getNotifications();
                const beforeCount = notificationsBefore.length;

                // Simular completar evaluaci√≥n para Mar√≠a
                TaskNotificationManager.removeEvaluationNotificationOnCompletion('eval_001', 'maria_estudiante');

                // Contar notificaciones despu√©s
                const notificationsAfter = TaskNotificationManager.getNotifications();
                const afterCount = notificationsAfter.length;

                // Verificar que Mar√≠a ya no reciba la notificaci√≥n
                const mariaNotificationsAfter = TaskNotificationManager.getUnreadNotificationsForUser('maria_estudiante', 'student');
                const mariaEvalNotificationsAfter = mariaNotificationsAfter.filter(n => n.taskId === 'eval_001');

                if (mariaEvalNotificationsAfter.length > 0) {
                    return { 
                        success: false, 
                        message: `‚ùå Mar√≠a a√∫n ve ${mariaEvalNotificationsAfter.length} notificaci√≥n(es) despu√©s de completar` 
                    };
                }

                return { 
                    success: true, 
                    message: `‚úÖ Eliminaci√≥n exitosa:<br>
                              üìä Notificaciones antes: ${beforeCount}<br>
                              üìä Notificaciones despu√©s: ${afterCount}<br>
                              üë§ Mar√≠a ya no ve notificaciones de eval_001` 
                };
            });

            // Test 4: Verificar mensaje "Sin Notificaciones Pendientes"
            addTest('Test 4: Mensaje "Sin Notificaciones Pendientes"', () => {
                // Crear un estudiante sin notificaciones
                const sinNotificaciones = TaskNotificationManager.getUnreadNotificationsForUser('estudiante_sin_tareas', 'student');
                
                // Simular la l√≥gica del componente
                const unreadComments = []; // Sin comentarios
                const taskNotifications = sinNotificaciones; // Sin notificaciones de tareas
                const pendingTasks = []; // Sin tareas pendientes

                const shouldShowNoNotifications = (
                    unreadComments.length === 0 && 
                    pendingTasks.length === 0 && 
                    taskNotifications.length === 0
                );

                if (!shouldShowNoNotifications) {
                    return { 
                        success: false, 
                        message: `‚ùå La l√≥gica no detecta correctamente el estado "sin notificaciones"<br>
                                  üìß Comentarios: ${unreadComments.length}<br>
                                  üìã Tareas pendientes: ${pendingTasks.length}<br>
                                  üîî Notificaciones: ${taskNotifications.length}` 
                    };
                }

                return { 
                    success: true, 
                    message: `‚úÖ L√≥gica correcta para mostrar "Sin Notificaciones Pendientes"<br>
                              üìß Comentarios: ${unreadComments.length}<br>
                              üìã Tareas pendientes: ${pendingTasks.length}<br>
                              üîî Notificaciones: ${taskNotifications.length}` 
                };
            });

            // Resultado final
            const finalDiv = document.createElement('div');
            finalDiv.className = `test-section ${allTestsPassed ? 'pass' : 'fail'}`;
            finalDiv.innerHTML = `
                <div class="test-header">
                    ${allTestsPassed ? 'üéâ TODOS LOS TESTS PASARON' : '‚ö†Ô∏è ALGUNOS TESTS FALLARON'}
                </div>
                <div class="result">
                    <strong>Estado:</strong> ${allTestsPassed ? 'SISTEMA FUNCIONANDO CORRECTAMENTE' : 'REQUIERE ATENCI√ìN'}
                </div>
            `;
            resultsDiv.appendChild(finalDiv);
        }

        // Ejecutar tests al cargar la p√°gina
        document.addEventListener('DOMContentLoaded', runTests);
    </script>
</body>
</html>
